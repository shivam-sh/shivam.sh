<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>Shivam Sh</title>
        <link>shivam.sh</link>
        <description>undefined</description>
        <lastBuildDate>Sun, 15 Jan 2023 06:08:21 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>Feed for Node.js</generator>
        <image>
            <title>Shivam Sh</title>
            <url>shivam.sh/logo.png</url>
            <link>shivam.sh</link>
        </image>
        <copyright>All rights reserved 2023, Shivam Sh</copyright>
        <item>
            <title><![CDATA[Turning Algorithms into Code]]></title>
            <link>shivam.sh/2020/algorithms-to-code</link>
            <guid>shivam.sh/2020/algorithms-to-code</guid>
            <pubDate>Mon, 27 Jul 2020 00:00:00 GMT</pubDate>
            <description><![CDATA[How do you go from an algorithm to working code? This post outlines a procedure to break this problem into manageable steps.]]></description>
            <content:encoded><![CDATA[<p><img src="https://shivam.sh/assets/blog/2020/a-star.png" alt="a-star"></p>
<h1>Turning Algorithms into Code</h1>
<p><a href="https://shivam-sh.github.io/p5-experiments/subpages/astar.html">End Result</a> <a href="https://github.com/shivam-sh/p5-experiments/tree/master/sketches/a*">Source Code</a></p>
<p>Algorithms are the fundamental building blocks of the code that we see around us. They take complicated problems and find solutions made of simple steps.</p>
<p>A few people have asked about how they can algorithms into code, so this post will go over the process.</p>
<p>This example will be recreating the A* pathfinding algorithm in JavaScript. This language will allow the results to be embedded right into the web. The same ideas should work perfectly fine with any other language and algorithm.</p>
<h2>Algorithms Aren't as Scary as They Look</h2>
<p>One of the most important things to realize is that algorithms are a combination of many simple steps and components. They can seem complicated with confusing parts but they're not that bad.</p>
<p>The steps in this post will show a way to turn an algorithm into working code but bugs and issues will almost always pop up. The goal of the post is to define steps to follow if someone doesn't know where to start.</p>
<h2>Understanding the Problem</h2>
<p>The first step when recreating any algorithm is researching the algorithm to understand what information it needs.</p>
<p>There are all sorts of algorithms on the internet with great descriptions. Reading up for a few minutes on your algorithm of choice is recommended to get an understanding of how it works.</p>
<p>It can be especially useful to find illustrations and animations depicting the algorithm at work. There are often long write-ups (often even including pseudo-code you can use as a base!) that discuss the inner workings of algorithms.</p>
<p>Algorithms often work with components like nodes and vectors but these just represent ways of storing data in an organized way.
You can use libraries that create and manage these components for you, but for this example will show you how to create these as well.</p>
<h2>Representing the Problem in Code</h2>
<p>A*, like other pathfinding algorithms, represents locations with edges and nodes. This means each major location is represented by a node, and the connections between the nodes are called edges.</p>
<p>A* then explores the nodes based on which nodes are the most beneficial (easy to travel to and bring us closer to the end). So we'll need a queue to store the list of nodes that the algorithm is looking into, as well as a list of nodes it is finished with.</p>
<p>Before programming, it can be very helpful to draw or take a note of how the code will work, as well as some of the functions the components will fulfill.</p>
<p>When writing the code we can refer to the diagram/notes to make the process smoother.</p>
<h4>Notes</h4>
<pre><code class="hljs language-js"><span class="hljs-comment">/*   Node
 * An object that represents a point on the map
 * Stores a h value (value that represents distance from finish line)
 * Stores a g value (cost of cheapest path to node)
 * Stores an f value (g + h)
 * Stores references to all surrounding nodes that it has connections to as well as the associated costs
 * Stores a reference to the node that precedes it on the cheapest known path
 * Stores x, y, w, and h to show itself (Specific to my graphical implementation)
 * Has many states associated with colours (Specific to my graphical implementation)
 */</span>

<span class="hljs-comment">/*   Grid: Node[][]
 * A cartesian graph of a bunch of nodes
 * Helps organize and visualize the nodes for easy display
 */</span>

<span class="hljs-comment">/*   Queue: Node[]
 *
 * A list of nodes to explore in order of which one should be looked at next
 * Nodes are organized in order of cost (lowest to greatest)
 * Based on the cost of the cheapest path to the node and its heuristic
 */</span>

<span class="hljs-comment">/*   Closed: Node[]
 * A list of nodes that have already been fully explored
</span></code></pre>
<h2>Programming</h2>
<p>Each step below has been linked to GitHub commit so you can follow along and see how the code evolved to reach completion.</p>
<h3>Part 1: Data Structures</h3>
<p>Now that the basics are outlined we can go ahead and make some template code. This represents the data and makes sure each of the parts we outlined is here.</p>
<p><a href="https://github.com/shivam-sh/p5-experiments/tree/50094f368e283345af86ab85cd959ab439d721ac/sketches/a*">View Commit</a></p>
<h4>sketch.js</h4>
<pre><code class="hljs language-js"><span class="hljs-comment">// Values for graphical output</span>
<span class="hljs-keyword">let</span> nodeHeight = <span class="hljs-number">30</span>;
<span class="hljs-keyword">let</span> nodeWidth = <span class="hljs-number">30</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// Code to create an adaptive canvas</span>
  <span class="hljs-keyword">let</span> canvasDiv = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'canvas'</span>);
  <span class="hljs-keyword">let</span> width = canvasDiv.<span class="hljs-property">offsetWidth</span>;
  <span class="hljs-keyword">let</span> height = canvasDiv.<span class="hljs-property">offsetHeight</span>;
  <span class="hljs-keyword">let</span> canvas = <span class="hljs-title function_">createCanvas</span>(width, height);
  canvas.<span class="hljs-title function_">parent</span>(<span class="hljs-string">'canvas'</span>);
  <span class="hljs-title function_">background</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);

  <span class="hljs-comment">// Setup values for grid</span>
  <span class="hljs-keyword">let</span> columns = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(width / nodeWidth);
  <span class="hljs-keyword">let</span> rows = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(height / nodeHeight);

  <span class="hljs-comment">// Create 2D grid</span>
  <span class="hljs-keyword">let</span> grid = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(columns);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &#x3C; columns; i++) {
    grid[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(rows);
  }

  <span class="hljs-comment">// Create storage for nodes</span>
  <span class="hljs-keyword">let</span> queue = [];
  <span class="hljs-keyword">let</span> closed = [];
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params"></span>) {}
</code></pre>
<h4>node.js</h4>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> states = {
  <span class="hljs-attr">OPEN</span>: <span class="hljs-string">'open'</span>,
  <span class="hljs-attr">BLOCKED</span>: <span class="hljs-string">'blocked'</span>,
  <span class="hljs-attr">START</span>: <span class="hljs-string">'start-node'</span>,
  <span class="hljs-attr">FINISH</span>: <span class="hljs-string">'end-node'</span>,
  <span class="hljs-attr">QUEUED</span>: <span class="hljs-string">'queued'</span>,
  <span class="hljs-attr">CLOSED</span>: <span class="hljs-string">'closed'</span>,
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MapNode</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x, y, w, h, state</span>) {
    <span class="hljs-comment">// f, g, and h values</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">f</span> = <span class="hljs-number">0</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">g</span> = <span class="hljs-number">0</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">h</span> = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// Array to store all connections</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">connected</span> = [];

    <span class="hljs-comment">// Ref to previous node</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cameFrom</span> = <span class="hljs-literal">undefined</span>;

    <span class="hljs-comment">// Data for visuals</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">xPos</span> = x;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">yPos</span> = y;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span> = w;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> = h;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = state;
  }
}
</code></pre>
<p>This part can vary depending on your implementation of the algorithm. This code declares a MapNode class, as the algorithm be working with many nodes. The class will make producing and managing the objects much easier. It will manage the data and functionality for each node.</p>
<p>Each list of nodes is declared as an array. Another data structure would work as well but arrays are easy to use in JavaScript and will work fine for this visualization.</p>
<p>The canvas is set up as soon as possible as it'll allow for easier debugging.</p>
<h4>Initialize the Algorithm</h4>
<p>Most algorithms need to work on top of a data set that is organized in a specific way. Try to make sure that everything is ready for the algorithm to run.</p>
<p><a href="https://github.com/shivam-sh/p5-experiments/tree/d4256c4227565dfca06b1cca61da87c6b0954b8a/sketches/a*">View Commit</a></p>
<h4>sketch.js</h4>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Grid Options</span>
<span class="hljs-keyword">let</span> percentFilled = <span class="hljs-number">30</span>;
<span class="hljs-keyword">let</span> nodeHeight = <span class="hljs-number">30</span>;
<span class="hljs-keyword">let</span> nodeWidth = <span class="hljs-number">30</span>;
...
<span class="hljs-keyword">function</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
    ...
    <span class="hljs-comment">// Fill the grid with nodes based on the % that should be open</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>; x &#x3C; columns; x++) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> y = <span class="hljs-number">0</span>; y &#x3C; rows; y++) {
            <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">100</span> > percentFilled) {
                grid[x][y] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MapNode</span>(
                    x,
                    y,
                    nodeWidth,
                    nodeHeight,
                    states.<span class="hljs-property">OPEN</span>
                );
            } <span class="hljs-keyword">else</span> {
                grid[x][y] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MapNode</span>(
                    x,
                    y,
                    nodeWidth,
                    nodeHeight,
                    states.<span class="hljs-property">BLOCKED</span>
                );
            }
        }
    }

    <span class="hljs-comment">// Set/init start and end points</span>
    start = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];
    finish = grid[columns - <span class="hljs-number">1</span>][rows - <span class="hljs-number">1</span>];
    start.<span class="hljs-title function_">setState</span>(states.<span class="hljs-property">OPEN</span>);
    finish.<span class="hljs-title function_">setState</span>(states.<span class="hljs-property">FINISH</span>);

    start.<span class="hljs-property">g</span> = <span class="hljs-number">0</span>;
    start.<span class="hljs-property">h</span> = <span class="hljs-title function_">dist</span>(start.<span class="hljs-property">column</span> * nodeWidth,
        start.<span class="hljs-property">row</span> * nodeHeight,
        finish.<span class="hljs-property">column</span> * nodeWidth,
        finish.<span class="hljs-property">row</span> * nodeHeight);
    start.<span class="hljs-property">f</span> = start.<span class="hljs-property">g</span> + start.<span class="hljs-property">h</span>;

    <span class="hljs-comment">// Add the start node to the queue</span>
    queue.<span class="hljs-title function_">push</span>(start);

    <span class="hljs-comment">// Output the base grid</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>; x &#x3C; columns; x++) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> y = <span class="hljs-number">0</span>; y &#x3C; rows; y++) {
            grid[x][y].<span class="hljs-title function_">show</span>();
        }
    }
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">if</span> (queue.<span class="hljs-property">length</span> > <span class="hljs-number">0</span>) {
        <span class="hljs-comment">// Run main search loop</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (start.<span class="hljs-property">state</span> != states.<span class="hljs-property">SUCCESS</span>) {
        <span class="hljs-comment">// Search failed</span>
    }
}
</code></pre>
<p>You may have noticed that I'm calling functions in this loop such as <code>.setState()</code> and <code>.show()</code> but they don't exist. Doing so allows you to architect the code in an organized manner from the start. This practice lets you know which functions each class will need as well as how they should be declared.</p>
<p>Another concern may be that the connections between the nodes aren't initialized. This network is organized as a grid and is optimizing accordingly. The node network will be dynamically generated as the algorithm searches. This will also allow for the visuals to be customized down the line to better show the algorithm at work.</p>
<h3>Implementing the Main Loop</h3>
<p>Next up is the main loop of the algorithm. It helps to follow the steps the algorithm takes and translate them into code sequentially.</p>
<p><a href="https://github.com/shivam-sh/p5-experiments/tree/46b6fe6d4abeb1d540d14ac881b77e0ea680174c/sketches/a*">View Commit</a></p>
<h4>sketch.js</h4>
<pre><code class="hljs language-javascript">...
<span class="hljs-keyword">function</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">if</span> (queue.<span class="hljs-property">length</span> > <span class="hljs-number">0</span>) {
        <span class="hljs-comment">// Run main search loop</span>
        <span class="hljs-keyword">let</span> currentNode = queue[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">let</span> newNodes = currentNode.<span class="hljs-title function_">getConnections</span>(grid);

        <span class="hljs-comment">// Check if done</span>
        <span class="hljs-keyword">if</span> (currentNode == finish) {
            <span class="hljs-keyword">while</span> (currentNode.<span class="hljs-property">cameFrom</span> != <span class="hljs-literal">undefined</span>) {
                currentNode.<span class="hljs-title function_">setState</span>(states.<span class="hljs-property">SUCCESS</span>);
                currentNode.<span class="hljs-title function_">show</span>();
                currentNode = currentNode.<span class="hljs-property">cameFrom</span>;
            }
            start.<span class="hljs-title function_">setState</span>(states.<span class="hljs-property">SUCCESS</span>);
            start.<span class="hljs-title function_">show</span>();
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// Remove current node from queue</span>
            currentNode.<span class="hljs-title function_">setState</span>(states.<span class="hljs-property">CLOSED</span>);
            currentNode.<span class="hljs-title function_">show</span>();
            closed.<span class="hljs-title function_">push</span>(currentNode);
            queue.<span class="hljs-title function_">shift</span>();

            <span class="hljs-comment">// Insert each connection into the queue according to its f value</span>
            newNodes.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">node</span>) =></span> {
                <span class="hljs-comment">// Check if this is the quickest path to this node</span>
                <span class="hljs-keyword">let</span> tempG =
                    currentNode.<span class="hljs-property">g</span> +
                    <span class="hljs-title function_">dist</span>(
                        currentNode.<span class="hljs-property">column</span> * nodeWidth,
                        currentNode.<span class="hljs-property">row</span> * nodeHeight,
                        node.<span class="hljs-property">column</span> * nodeWidth,
                        node.<span class="hljs-property">row</span> * nodeHeight
                    );

                <span class="hljs-keyword">if</span> (tempG &#x3C; node.<span class="hljs-property">g</span>) {
                    node.<span class="hljs-property">h</span> = <span class="hljs-title function_">dist</span>(
                        node.<span class="hljs-property">column</span> * nodeWidth,
                        node.<span class="hljs-property">row</span> * nodeHeight,
                        finish.<span class="hljs-property">column</span> * nodeWidth,
                        finish.<span class="hljs-property">row</span> * nodeHeight
                    );
                    node.<span class="hljs-property">cameFrom</span> = currentNode;
                    node.<span class="hljs-property">g</span> = tempG;
                    node.<span class="hljs-property">f</span> = node.<span class="hljs-property">g</span> + node.<span class="hljs-property">h</span>;
                }

                <span class="hljs-comment">// Add the node to the queue and sort</span>
                queue.<span class="hljs-title function_">push</span>(node);
                queue.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =></span> a.<span class="hljs-property">f</span> - b.<span class="hljs-property">f</span>);
                node.<span class="hljs-title function_">setState</span>(states.<span class="hljs-property">QUEUED</span>);
                node.<span class="hljs-title function_">show</span>();
            });
        }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (start.<span class="hljs-property">state</span> != states.<span class="hljs-property">SUCCESS</span>) {
        <span class="hljs-comment">// Search failed</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>; x &#x3C; columns; x++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> y = <span class="hljs-number">0</span>; y &#x3C; rows; y++) {
                <span class="hljs-keyword">if</span> (grid[x][y].<span class="hljs-property">state</span> == states.<span class="hljs-property">CLOSED</span>) {
                    grid[x][y].<span class="hljs-title function_">setState</span>(states.<span class="hljs-property">FAILED</span>);
                    grid[x][y].<span class="hljs-title function_">show</span>();
                }
            }
        }
    }
}
</code></pre>
<p>You can see that the main algorithm is already done being implemented. There will likely be bugs during the first implementation but they should be ironed out in the next step.</p>
<p>By focusing in on one area it's easier to be mindful of what is happening, and thus it helps develop a better understanding of how the code works. This helps make the debugging process run smoother in the end.</p>
<p>Again, some of the methods being called don't exist yet. This makes sure that the main loop isn't doing too much. It's easy to go ahead and implement everything into this loop, but doing so makes for messier code that becomes more difficult to maintain.</p>
<h3>Making Your Code Functional</h3>
<p>Now it's time to build the functions that have been called in the rest of the code. The functions can be added pretty quickly. The inputs, return values, and functionality is already outlined through the calls.</p>
<p><a href="https://github.com/shivam-sh/p5-experiments/tree/17b721e99086714d20765d7c5d97c1111123164a/sketches/a*">View Commit</a></p>
<h4>node.js</h4>
<pre><code class="hljs language-javascript">...

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MapNode</span> {
    ...

    <span class="hljs-comment">// Returns an array with a list of connected nodes</span>
    <span class="hljs-title function_">getConnections</span>(<span class="hljs-params">grid</span>) {
        <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">connected</span> == []) {
            <span class="hljs-keyword">if</span> (
                <span class="hljs-variable language_">this</span>.<span class="hljs-property">column</span> != <span class="hljs-number">0</span> &#x26;&#x26;
                (grid[<span class="hljs-variable language_">this</span>.<span class="hljs-property">column</span> - <span class="hljs-number">1</span>][<span class="hljs-variable language_">this</span>.<span class="hljs-property">row</span>].<span class="hljs-property">state</span> == states.<span class="hljs-property">OPEN</span> ||
                    grid[<span class="hljs-variable language_">this</span>.<span class="hljs-property">column</span> - <span class="hljs-number">1</span>][<span class="hljs-variable language_">this</span>.<span class="hljs-property">row</span>].<span class="hljs-property">state</span> == states.<span class="hljs-property">FINISH</span>)
            ) {
                <span class="hljs-variable language_">this</span>.<span class="hljs-property">connected</span>.<span class="hljs-title function_">push</span>(grid[<span class="hljs-variable language_">this</span>.<span class="hljs-property">column</span> - <span class="hljs-number">1</span>][<span class="hljs-variable language_">this</span>.<span class="hljs-property">row</span>]);
            }
            ...
            <span class="hljs-keyword">if</span> (
                <span class="hljs-variable language_">this</span>.<span class="hljs-property">row</span> != grid[<span class="hljs-number">0</span>].<span class="hljs-property">length</span> - <span class="hljs-number">1</span> &#x26;&#x26;
                <span class="hljs-variable language_">this</span>.<span class="hljs-property">column</span> != grid.<span class="hljs-property">length</span> - <span class="hljs-number">1</span> &#x26;&#x26;
                (grid[<span class="hljs-variable language_">this</span>.<span class="hljs-property">column</span> + <span class="hljs-number">1</span>][<span class="hljs-variable language_">this</span>.<span class="hljs-property">row</span> + <span class="hljs-number">1</span>].<span class="hljs-property">state</span> == states.<span class="hljs-property">OPEN</span> ||
                    grid[<span class="hljs-variable language_">this</span>.<span class="hljs-property">column</span> + <span class="hljs-number">1</span>][<span class="hljs-variable language_">this</span>.<span class="hljs-property">row</span> + <span class="hljs-number">1</span>].<span class="hljs-property">state</span> == states.<span class="hljs-property">FINISH</span>)
            ) {
                <span class="hljs-variable language_">this</span>.<span class="hljs-property">connected</span>.<span class="hljs-title function_">push</span>(grid[<span class="hljs-variable language_">this</span>.<span class="hljs-property">column</span> + <span class="hljs-number">1</span>][<span class="hljs-variable language_">this</span>.<span class="hljs-property">row</span> + <span class="hljs-number">1</span>]);
            }

            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">connected</span>;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">connected</span>;
        }
    }

    <span class="hljs-comment">// Changes the state of the node</span>
    <span class="hljs-title function_">setState</span>(<span class="hljs-params">state</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = state;
    }

    <span class="hljs-comment">// Sets the cameFrom variable to a new node</span>
    <span class="hljs-title function_">setCameFrom</span>(<span class="hljs-params">node</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">cameFrom</span> = node;
    }
}
</code></pre>
<p>At this point the code is functional!</p>
<p>This step can take a long time as the bugs that were unnoticed in the previous steps tend to show themselves at this point.</p>
<p>This step can be frustrating due to all the debugging that can be involved, but it's also the one that finally gets your code to a working state.</p>
<h2>Optimization/Finishing Touches</h2>
<p>The last step of the process (usually also my favourite) is the finishing touches.</p>
<p>This is usually a lot of tweaking values and objects to get everything running and looking as nice as possible.</p>
<p>This step doesn't have any instructions or guidelines but that's the best part!</p>
<p><a href="https://github.com/shivam-sh/p5-experiments/tree/master/sketches/a*">View Code</a></p>
<h2>Conclusion</h2>
<p>Throughout this post, we (hopefully) successfully translated an algorithm into code.</p>
<p>Go ahead and use this process to code something that interests you! The process won't be the same for every problem but that's the best part. Either way, you come out of the experience learning something new.</p>
<p>Reach out to me and let me know what you've made by following these steps!</p>
<h4>Shivam Sh</h4>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Exploring Asynchronous Programming]]></title>
            <link>shivam.sh/2020/exploring-async-programming</link>
            <guid>shivam.sh/2020/exploring-async-programming</guid>
            <pubDate>Thu, 09 Jul 2020 00:00:00 GMT</pubDate>
            <description><![CDATA[A reflection on my latest project. I explore server-side programming through Node.js thanks to a brief introduction while working on a bot.]]></description>
            <content:encoded><![CDATA[<h1>Exploring Asynchronous Programming</h1>
<h2>Background</h2>
<p>Recently, I've been managing a Discord server for the incoming wave of Systems Design Engineering students at Waterloo. The Discord is being used as a communication platform as well as a virtual meeting place to help us get to know each other.
There was only one problem. There were already over 200 members in the server yet there were only around 100 people coming into the program this year.</p>
<p>There was a clear problem with the fact that almost anyone could join the server. Verifying that they were meant to be in the server was just an inefficient process.
We needed a verification system. To solve this problem, I decided to make a discord bot that would work with the University of Waterloo's Open Data APIs. This would allow me to check someone's department and email them a verification token to confirm their identity.</p>
<p>This would be my first real server-side project as well as one of my first times using Node.js. The main code itself only took about a week to develop into a working state, but I ended up learning a whole lot about server-side development and asynchronous programming.</p>
<p>For information about the code and how it works click on <a href="https://github.com/shivam-sh/goose-bot">this GitHub link.</a> The code is completely open-source on my GitHub so feel free to check it out.</p>
<h2>Newly Explored</h2>
<p>An unprecedented consequence I faced with Node.js was the asynchronous execution of code. This means that multiple parts of the code can be running at the same time rather than the chain of events that occurs during synchronous programs.</p>
<p>This shift in the way code is executed ended up meaning that I'd use a day just to take a deep dive into the world of asynchronous code execution, and promises. I couldn't just call my own functions and deal with the return values right away. I would have to ensure that the returns were accessible to the next steps of the program so the parts that had to run in sync knew when their information was ready.</p>
<p>I found two main ways in which this balance between synchronous and asynchronous operations are kept. Either through promises, or through async/await.</p>
<h3>Promises</h3>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> {
  <span class="hljs-comment">// Run a certain task that takes time </span>
  <span class="hljs-comment">// End by either resolving or rejecting/throwing an error</span>
})
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =></span> {
    <span class="hljs-comment">// Take in the result of the previous promise and perform a task with it </span>
    <span class="hljs-comment">// .then can even return another promise itself to make a "promise chain"</span>
  })
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =></span> {
    <span class="hljs-comment">// Runs if the promises above it throw an error or aren't resolved. </span>
    <span class="hljs-comment">// You can have multiple catches in a promise chain for error correction</span>
  });
</code></pre>
<p>Promises are the first way in which synchronicity is managed. They either return a usable value, or will return an error that was created during their run. Their main feature is their ability to alert the program when they are done with their task. This means that the next portion of the code knows exactly when it should run.</p>
<p>Promises either complete, or return an error. This means it is relatively easy to manage the next steps in the operation. One can either continue on with the operation, or catch the error and manage it. The .then() and .catch() blocks capture these two possibilities and take in what is returned in either case. This makes for a fairly intuitive way of managing tasks that have to be executed in order in an otherwise asynchronous program.</p>
<h3>Async/Await</h3>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {

  <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// Carries out a task that takes time then returns something</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }

  <span class="hljs-keyword">await</span> <span class="hljs-title function_">doSomething</span>();

  <span class="hljs-comment">// Continue with something else after doSomething() finishes</span>
  <span class="hljs-comment">// The await keyword told the program to wait for the function to stop</span>
}
</code></pre>
<p>The second way to manage synchronous blocks of code is with async and await. This method simply exposes another interface for dealing with promises. Under the hood they both work the same way.</p>
<p>Note that the example code this time is running inside a function initialized with the async keyword. The async keyword ensures that the function returns a promise and runs in the background, preventing the rest of your code from having to pause while waiting for a result.
This is necessary in order to allow the <code>await</code> keyword to be used. Await tells the program to wait for the code that you have just called to finish executing before carrying on with the next steps.</p>
<p>Await can be used to call any function labeled with async, or in other words, any promise.</p>
<h3>Mix &#x26; Match</h3>
<p>Promises and async/await work the same way behind the scenes. The shared frameworks that back up promises and async/await mean that the two can be used together. The <code>await</code> keyword can be used when calling any promises, and the <code>.then()</code> and <code>.catch()</code> code blocks can be used when you call any functions initialized with async since they are actually just promises!</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// Carries out a task that takes time then returns something</span>

  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}

<span class="hljs-title function_">doSomething</span>()
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">json</span>) =></span> {
   <span class="hljs-comment">// Do something else</span>
  })
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =></span> {
   <span class="hljs-comment">// Manage error</span>
  });

</code></pre>
<p>In fact, the two variants allow you to carry out the exact same task just with different syntax. Here is some code that accesses a json based API from the web written to accomplish the same task using both methods.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Import fetch function to pull json from web</span>
<span class="hljs-keyword">const</span> fetch = <span class="hljs-built_in">require</span>(<span class="hljs-string">"node-fetch"</span>);

<span class="hljs-comment">// Fetching JSON from the web with a promise</span>
<span class="hljs-title function_">fetch</span>(<span class="hljs-string">"https://jsonplaceholder.typicode.com/posts/1"</span>)
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =></span> result.<span class="hljs-title function_">json</span>())
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">json</span>) =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Done fetching data with Promises!"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(json);
  })
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Uh Oh! Something went wrong with my promise!"</span>);
  });

<span class="hljs-comment">// Fetching JSON from the web with async &#x26; await</span>
<span class="hljs-title function_">runAsync</span>();

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">runAsync</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">"https://jsonplaceholder.typicode.com/posts/1"</span>);
    result = result.<span class="hljs-title function_">json</span>();
    <span class="hljs-keyword">return</span> result;
  }

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">let</span> json = <span class="hljs-keyword">await</span> <span class="hljs-title function_">doSomething</span>();

    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Done fetching data with Async/Await!"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(json);
  } <span class="hljs-keyword">catch</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(
      <span class="hljs-string">"Uh Oh! Something went wrong during when I tried to doSomething!"</span>
    );
  }
}
</code></pre>
<h2>Wrap-Up</h2>
<p>Exploring some asynchronous programming thanks to my work on a identity-verification bot allowed me to develop a far better understanding of how information is dealt with on the web and on servers.
This is definitely a topic I'm looking forward to digging deeper on so keep an eye out for future projects and blog posts that'll expand on the basics in this post.</p>
<p>As for Goose Bot, I'm definitely going to be adding more features to it to help out with the Discord server. So if you want to see how it works or how to implement something similar the <a href="https://github.com/shivam-sh/goose-bot">GitHub</a> should be pretty helpful. I tried my best to ensure that the code is either self explanatory or commented to be easy to understand.</p>
<h4>Shivam Sh</h4>]]></content:encoded>
        </item>
    </channel>
</rss>